---
description: Spring Security, JWT ì¸ì¦/ì¸ê°€, OAuth 2.0, ë¹„ë°€ë²ˆí˜¸ ì •ì±…, ë³´ì•ˆ ì·¨ì•½ì  ë°©ì§€ì™€ ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
globs: 
alwaysApply: false
---
# ğŸ” ë³´ì•ˆ ê°€ì´ë“œë¼ì¸ ë° ì¸ì¦ ì‹œìŠ¤í…œ

## ğŸ›¡ï¸ ê¸°ë³¸ ë³´ì•ˆ ì›ì¹™

### í•µì‹¬ ë³´ì•ˆ ê·œì¹™
- **ìµœì†Œ ê¶Œí•œ ì›ì¹™**: í•„ìš”í•œ ìµœì†Œí•œì˜ ê¶Œí•œë§Œ ë¶€ì—¬
- **ë‹¤ì¸µ ë³´ì•ˆ**: ì—¬ëŸ¬ ë³´ì•ˆ ê³„ì¸µìœ¼ë¡œ ì‹œìŠ¤í…œ ë³´í˜¸
- **ë³´ì•ˆ ê¸°ë³¸ê°’**: ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  ê²ƒì„ ì°¨ë‹¨í•˜ê³  í•„ìš”í•œ ê²ƒë§Œ í—ˆìš©
- **ë¯¼ê° ì •ë³´ ë³´í˜¸**: ë¡œê·¸, ì‘ë‹µì—ì„œ ë¯¼ê° ì •ë³´ ì œê±°

## ğŸ”‘ JWT í† í° ê´€ë¦¬ ê·œì¹™

### JWT ì„¤ì • ë° êµ¬ì¡°
```java
@Component
@Slf4j
public class JwtUtils {
    
    @Value("${jwt.secret}")
    private String secretKey;
    
    @Value("${jwt.access-token-expiration:3600000}")  // 1ì‹œê°„
    private long accessTokenExpiration;
    
    @Value("${jwt.refresh-token-expiration:604800000}")  // 7ì¼
    private long refreshTokenExpiration;
    
    private Key getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }
    
    public String generateAccessToken(User user) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId());
        claims.put("email", user.getEmail());
        claims.put("roles", user.getRoles().stream()
            .map(Role::getName)
            .collect(Collectors.toList()));
        
        return createToken(claims, user.getEmail(), accessTokenExpiration);
    }
    
    public String generateRefreshToken(User user) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", user.getId());
        claims.put("tokenType", "refresh");
        
        return createToken(claims, user.getEmail(), refreshTokenExpiration);
    }
    
    private String createToken(Map<String, Object> claims, String subject, long expiration) {
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + expiration))
            .signWith(getSigningKey(), SignatureAlgorithm.HS512)
            .compact();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token);
            return true;
        } catch (ExpiredJwtException e) {
            log.warn("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.warn("JWT token is unsupported: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.warn("Invalid JWT token: {}", e.getMessage());
        } catch (SignatureException e) {
            log.warn("Invalid JWT signature: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.warn("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }
}
```

### JWT í•„í„° êµ¬í˜„
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    private final JwtUtils jwtUtils;
    private final UserDetailsService userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                   HttpServletResponse response, 
                                   FilterChain filterChain) throws ServletException, IOException {
        
        try {
            String token = extractTokenFromRequest(request);
            
            if (token != null && jwtUtils.validateToken(token)) {
                String username = jwtUtils.getUsernameFromToken(token);
                
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                UsernamePasswordAuthenticationToken authToken = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        } catch (Exception e) {
            log.error("Cannot set user authentication: {}", e.getMessage());
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
    
    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getRequestURI();
        return path.startsWith("/api/v1/auth/") || 
               path.startsWith("/api/v1/health") ||
               path.startsWith("/swagger-ui/") ||
               path.startsWith("/v3/api-docs");
    }
}
```

## ğŸ”’ Spring Security ì„¤ì •

### SecurityConfig í´ë˜ìŠ¤
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final PasswordEncoder passwordEncoder;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                // ê³µê°œ ì—”ë“œí¬ì¸íŠ¸
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/health").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                
                // ê´€ë¦¬ì ì „ìš© ì—”ë“œí¬ì¸íŠ¸
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                
                // ì¸ì¦ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸
                .requestMatchers("/api/v1/users/**").hasAnyRole("USER", "ADMIN")
                .requestMatchers("/api/v1/documents/**").hasAnyRole("USER", "ADMIN")
                
                // ë‚˜ë¨¸ì§€ëŠ” ëª¨ë‘ ì¸ì¦ í•„ìš”
                .anyRequest().authenticated()
            )
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService());
        authProvider.setPasswordEncoder(passwordEncoder);
        return authProvider;
    }
    
    @Bean
    public UserDetailsService userDetailsService() {
        return new CustomUserDetailsService();
    }
}
```

### ì»¤ìŠ¤í…€ UserDetailsService
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class CustomUserDetailsService implements UserDetailsService {
    
    private final UserRepository userRepository;
    
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new UsernameNotFoundException("User not found: " + email));
        
        return SecurityUser.from(user);
    }
}

@Getter
public class SecurityUser implements UserDetails {
    private final Long id;
    private final String email;
    private final String password;
    private final List<GrantedAuthority> authorities;
    private final boolean enabled;
    
    private SecurityUser(Long id, String email, String password, 
                        List<GrantedAuthority> authorities, boolean enabled) {
        this.id = id;
        this.email = email;
        this.password = password;
        this.authorities = authorities;
        this.enabled = enabled;
    }
    
    public static SecurityUser from(User user) {
        List<GrantedAuthority> authorities = user.getRoles().stream()
            .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName()))
            .collect(Collectors.toList());
        
        return new SecurityUser(
            user.getId(),
            user.getEmail(),
            user.getPassword(),
            authorities,
            user.isActive()
        );
    }
    
    @Override
    public String getUsername() {
        return email;
    }
    
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
    
    @Override
    public boolean isEnabled() {
        return enabled;
    }
}
```

## ğŸŒ OAuth 2.0 êµ¬í˜„

### OAuth í´ë¼ì´ì–¸íŠ¸ ì¸í„°í˜ì´ìŠ¤
```java
public interface OAuthClient {
    String getProviderName();
    OAuthUserInfo getUserInfo(String accessToken);
    boolean supports(OAuthProvider provider);
}

@Getter
@Builder
public class OAuthUserInfo {
    private final String providerId;
    private final String email;
    private final String name;
    private final String profileImageUrl;
    private final OAuthProvider provider;
}
```

### Google OAuth í´ë¼ì´ì–¸íŠ¸
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class GoogleOAuthClient implements OAuthClient {
    
    @Value("${oauth.google.user-info-url}")
    private String userInfoUrl;
    
    private final RestTemplate restTemplate;
    
    @Override
    public String getProviderName() {
        return "google";
    }
    
    @Override
    public OAuthUserInfo getUserInfo(String accessToken) {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setBearerAuth(accessToken);
            HttpEntity<String> entity = new HttpEntity<>(headers);
            
            ResponseEntity<GoogleUserResponse> response = restTemplate.exchange(
                userInfoUrl,
                HttpMethod.GET,
                entity,
                GoogleUserResponse.class
            );
            
            GoogleUserResponse userResponse = response.getBody();
            
            return OAuthUserInfo.builder()
                .providerId(userResponse.getId())
                .email(userResponse.getEmail())
                .name(userResponse.getName())
                .profileImageUrl(userResponse.getPicture())
                .provider(OAuthProvider.GOOGLE)
                .build();
                
        } catch (Exception e) {
            log.error("Failed to get user info from Google: {}", e.getMessage());
            throw new OAuthException("Failed to get user info from Google", e);
        }
    }
    
    @Override
    public boolean supports(OAuthProvider provider) {
        return provider == OAuthProvider.GOOGLE;
    }
}

@Getter
@JsonIgnoreProperties(ignoreUnknown = true)
public class GoogleUserResponse {
    private String id;
    private String email;
    private String name;
    private String picture;
    
    @JsonProperty("verified_email")
    private boolean verifiedEmail;
}
```

### Apple OAuth í´ë¼ì´ì–¸íŠ¸
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class AppleOAuthClient implements OAuthClient {
    
    private final AppleJwtUtils appleJwtUtils;
    
    @Override
    public String getProviderName() {
        return "apple";
    }
    
    @Override
    public OAuthUserInfo getUserInfo(String identityToken) {
        try {
            // Apple Identity Token ê²€ì¦ ë° íŒŒì‹±
            Claims claims = appleJwtUtils.parseAndValidateToken(identityToken);
            
            return OAuthUserInfo.builder()
                .providerId(claims.getSubject())
                .email(claims.get("email", String.class))
                .name(claims.get("name", String.class))
                .provider(OAuthProvider.APPLE)
                .build();
                
        } catch (Exception e) {
            log.error("Failed to parse Apple identity token: {}", e.getMessage());
            throw new OAuthException("Failed to parse Apple identity token", e);
        }
    }
    
    @Override
    public boolean supports(OAuthProvider provider) {
        return provider == OAuthProvider.APPLE;
    }
}
```

## ğŸ” ë¹„ë°€ë²ˆí˜¸ ì •ì±…

### ë¹„ë°€ë²ˆí˜¸ ê²€ì¦ ê·œì¹™
```java
@Component
public class PasswordValidator {
    
    private static final int MIN_LENGTH = 8;
    private static final int MAX_LENGTH = 128;
    private static final String SPECIAL_CHARACTERS = "!@#$%^&*()_+-=[]{}|;:,.<>?";
    
    public void validatePassword(String password) {
        List<String> errors = new ArrayList<>();
        
        if (password == null || password.length() < MIN_LENGTH) {
            errors.add("Password must be at least " + MIN_LENGTH + " characters long");
        }
        
        if (password != null && password.length() > MAX_LENGTH) {
            errors.add("Password must not exceed " + MAX_LENGTH + " characters");
        }
        
        if (password != null) {
            if (!password.matches(".*[a-z].*")) {
                errors.add("Password must contain at least one lowercase letter");
            }
            
            if (!password.matches(".*[A-Z].*")) {
                errors.add("Password must contain at least one uppercase letter");
            }
            
            if (!password.matches(".*\\d.*")) {
                errors.add("Password must contain at least one digit");
            }
            
            if (!containsSpecialCharacter(password)) {
                errors.add("Password must contain at least one special character");
            }
        }
        
        if (!errors.isEmpty()) {
            throw new InvalidPasswordException(String.join(", ", errors));
        }
    }
    
    private boolean containsSpecialCharacter(String password) {
        return password.chars()
            .anyMatch(ch -> SPECIAL_CHARACTERS.indexOf(ch) >= 0);
    }
}
```

## ğŸš« ë³´ì•ˆ ì·¨ì•½ì  ë°©ì§€

### 1. SQL Injection ë°©ì§€
```java
// âœ… ì¢‹ì€ ì˜ˆ: JPA Repository ì‚¬ìš©
@Query("SELECT u FROM User u WHERE u.email = :email AND u.status = :status")
Optional<User> findByEmailAndStatus(@Param("email") String email, 
                                   @Param("status") UserStatus status);

// âŒ ë‚˜ìœ ì˜ˆ: ë™ì  ì¿¼ë¦¬ ë¬¸ìì—´ ì¡°í•©
@Query(value = "SELECT * FROM users WHERE email = '" + email + "'", nativeQuery = true)
List<User> findByEmailUnsafe(String email);
```

### 2. XSS (Cross-Site Scripting) ë°©ì§€
```java
@Component
public class HtmlSanitizer {
    
    private final Whitelist whitelist = Whitelist.basic();
    
    public String sanitize(String input) {
        if (input == null) {
            return null;
        }
        return Jsoup.clean(input, whitelist);
    }
}

// DTOì—ì„œ ì‚¬ìš©
@Getter
@Setter
public class CreatePostRequest {
    
    @NotBlank
    @Size(max = 200)
    private String title;
    
    @NotBlank
    @Size(max = 5000)
    private String content;
    
    // Setterì—ì„œ XSS ë°©ì§€
    public void setTitle(String title) {
        this.title = htmlSanitizer.sanitize(title);
    }
    
    public void setContent(String content) {
        this.content = htmlSanitizer.sanitize(content);
    }
}
```

### 3. CSRF ë°©ì§€ (REST APIì—ì„œëŠ” JWT ì‚¬ìš©ìœ¼ë¡œ ìë™ ë°©ì§€)
```java
// JWT ê¸°ë°˜ APIì—ì„œëŠ” CSRF ë¹„í™œì„±í™”
http.csrf(csrf -> csrf.disable())
```

### 4. Rate Limiting êµ¬í˜„
```java
@Component
@RequiredArgsConstructor
public class RateLimitingFilter implements Filter {
    
    private final RedisTemplate<String, String> redisTemplate;
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        String clientIp = getClientIp(httpRequest);
        String key = "rate_limit:" + clientIp;
        
        String count = redisTemplate.opsForValue().get(key);
        
        if (count == null) {
            redisTemplate.opsForValue().set(key, "1", Duration.ofMinutes(1));
        } else if (Integer.parseInt(count) >= 100) { // ë¶„ë‹¹ 100íšŒ ì œí•œ
            httpResponse.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            httpResponse.getWriter().write("Rate limit exceeded");
            return;
        } else {
            redisTemplate.opsForValue().increment(key);
        }
        
        chain.doFilter(request, response);
    }
    
    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }
}
```

## ğŸ“‹ ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê°œë°œ ì‹œ í•„ìˆ˜ í™•ì¸ì‚¬í•­
- [ ] ëª¨ë“  API ì—”ë“œí¬ì¸íŠ¸ì— ì ì ˆí•œ ì¸ì¦/ì¸ê°€ ì„¤ì •
- [ ] ë¯¼ê° ì •ë³´(ë¹„ë°€ë²ˆí˜¸, í† í°)ê°€ ë¡œê·¸ì— ë…¸ì¶œë˜ì§€ ì•ŠìŒ
- [ ] SQL Injection ë°©ì§€ë¥¼ ìœ„í•œ PreparedStatement ì‚¬ìš©
- [ ] XSS ë°©ì§€ë¥¼ ìœ„í•œ ì…ë ¥ê°’ ê²€ì¦ ë° ì´ìŠ¤ì¼€ì´í”„
- [ ] HTTPS ê°•ì œ ì‚¬ìš© (ìš´ì˜ í™˜ê²½)
- [ ] ì ì ˆí•œ CORS ì„¤ì •
- [ ] íŒŒì¼ ì—…ë¡œë“œ ì‹œ íŒŒì¼ íƒ€ì… ë° í¬ê¸° ê²€ì¦
- [ ] Rate Limiting ì ìš©
- [ ] ì—ëŸ¬ ë©”ì‹œì§€ì—ì„œ ì‹œìŠ¤í…œ ì •ë³´ ë…¸ì¶œ ë°©ì§€

### ë°°í¬ ì „ ë³´ì•ˆ ê²€ì¦
- [ ] ê¸°ë³¸ ê³„ì • ë¹„ë°€ë²ˆí˜¸ ë³€ê²½
- [ ] ë¶ˆí•„ìš”í•œ í¬íŠ¸ ì°¨ë‹¨
- [ ] ë³´ì•ˆ í—¤ë” ì„¤ì • (HSTS, X-Frame-Options ë“±)
- [ ] ë¡œê·¸ ë ˆë²¨ ì ì ˆíˆ ì„¤ì • (ìš´ì˜ í™˜ê²½ì—ì„œ DEBUG ë¹„í™œì„±í™”)
- [ ] JWT Secret Key ì¶©ë¶„íˆ ë³µì¡í•˜ê²Œ ì„¤ì • (ìµœì†Œ 256bit)
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì ‘ê·¼ ê¶Œí•œ ìµœì†Œí™”
